[{"content":"目录 2.1 设计模式的概念与分类\n2.2 面向对象设计原则与UML类图\n2.3 UML类图关系\n三、行为型模式\n3.1 状态模式的实现\n3.2 中介模式\n3.3 职责链模式\n四、创建型模式\n4.1 适配器模式\n4.2 单例模式\n4.3 原型模式\n五、结构型模式\n5.1 装饰模式\n5.2 代理模式\n","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/1.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%9B%AE%E5%BD%95/","title":"1.1设计模式-目录"},{"content":"[toc]\n一、设计模式的概念与分类\n一、设计模式的概念与分类 1.1 设计模式是什么 设计模式的一般定义如下： 设计模式（Design Pattern）是一套被反复使用的、多数人知晓的、经过分类编目的代码设计经验的总结，使用设计模式是为了可以重用代码，让代码更容易被他人理解并且提高代码的可靠性。 狭义的设计模式是指GoF在Design Patterns：Elements of Reusable Object-Oriented Software（《设计模式：可复用面向对象软件的基础》）一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种，随着软件开发技术的发展，越来越多的新模式不断诞生并得以应用。本书将主要围绕GoF 23种模式进行讲解。 设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。模式名称（Pattern Name）通过一两个词来为模式命名，以便我们更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名）；问题（Problem）描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；解决方案（Solution）描述了一个设计模式的组成部分，以及这些组成部分之间的相互关系、各自的职责和协作方式，通常解决方案通过UML类图和核心代码进行描述；效果（Consequence）描述了模式的优缺点以及在使用模式时应权衡的问题。\n1.2 设计模式的分类 创建型模式主要用于描述如何创建对象；结构型模式主要用于描述如何实现类或对象的组合；行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。\n![image-20241005161029528](/Users/baidongdong/Library/Application Support/typora-user-images/image-20241005161029528.png)\n创建型 结构型 行为型 单例模式 适配器模式 职责链模式 简单工厂模式 桥接模式 命令模式 工厂方法模式 组合模式 解释器模式 抽象工厂模式 装饰模式 迭代器模式 原型模式 外观模式 中介者模式 建造者模式 享元模式 备忘录模式 代理模式 观察者模式 状态模式 策略模式 模版方法模式 访问者模式 根据某个模式主要是用于处理类之间的关系还是用于处理对象之间的关系，设计模式还可以分为类模式和对象模式。\n类模式 对象模式 单例模式 1.3 开发模式之间的相同点与区别，以及联系 1. 三大类设计模式的总体区别：\n​\t•\t创建型模式（Creational Patterns）：\n关注对象的创建过程，确保以适当的方式创建对象，避免复杂的实例化操作。\n​\t•\t结构型模式（Structural Patterns）：\n关注类与对象的组合，通过适当的组合方式构建更大、更复杂的结构，注重类和对象之间的关系。\n​\t•\t行为型模式（Behavioral Patterns）：\n关注对象之间的职责划分与交互方式，描述对象如何协作完成任务.\n2. 设计模式的相同点：\n​\t•\t解耦性：大多数设计模式都遵循高内聚低耦合的原则，旨在减少类之间的依赖。例如，工厂模式将对象创建与使用解耦，策略模式将算法的选择与使用者解耦。\n​\t•\t复用性：设计模式鼓励代码复用，通过抽象的类和接口提高复用性。例如，组合模式允许将对象组合成树形结构，从而实现复用与灵活操作，装饰器模式通过对象的组合来增强行为，而不需要修改原始类。\n​\t•\t封装变化：大多数设计模式旨在将变化封装起来，减少外界对变化的感知。例如，策略模式封装了不同的算法实现，外部无需关心算法的变化；工厂模式封装了对象的创建细节。\n​\t•\t松耦合的对象协作：许多设计模式通过对象之间的松散协作实现更灵活的代码结构，减少系统各部分的依赖。例如，观察者模式允许多个观察者对象监听同一事件，观察者和被观察者之间松耦合。\n3. 各设计模式的区别：\n​\t•\t创建型模式的区别：\n​\t•\t工厂方法模式：定义一个接口用于创建对象，但将具体实现推迟到子类，适用于需要灵活选择类的场景。\n​\t•\t抽象工厂模式：提供一个接口，用于创建一系列相关或依赖的对象，而不指定具体的类。适用于需要创建一组相关对象的情况。\n​\t•\t单例模式：确保一个类只有一个实例，并提供全局访问点。用于需要唯一实例的场景，如配置管理。\n​\t•\t建造者模式：将对象的构造与表示分离，使得相同的构造过程可以创建不同的对象表示。适合复杂对象的创建。\n​\t•\t原型模式：通过复制已有对象来创建新对象，而不是通过类构造器。适用于类初始化成本高的场景。\n​\t•\t结构型模式的区别：\n​\t•\t适配器模式：将不兼容的接口进行适配，使得原本由于接口不兼容而不能一起工作的类能够协同工作。\n​\t•\t桥接模式：将抽象部分与实现部分分离，使得它们可以独立变化，适用于需要灵活扩展和变化的场景。\n​\t•\t组合模式：将对象组合成树形结构，处理对象与对象组合具有一致的方式。适用于部分-整体层次结构的场景。\n​\t•\t装饰器模式：动态地给对象添加新的职责，而不改变其接口。适用于需要动态扩展对象功能的场景。\n​\t•\t外观模式：提供一个统一的接口，简化系统复杂性，隐藏系统内部的细节。\n​\t•\t享元模式：通过共享技术减少内存消耗，适用于大量细粒度对象的场景。\n​\t•\t代理模式：提供一个对象的代理，以控制对该对象的访问，适用于延迟加载、权限控制等场景。\n​\t•\t行为型模式的区别：\n​\t•\t责任链模式：为请求创建一条处理链，依次传递请求，直到找到合适的处理器。\n​\t•\t命令模式：将请求封装为对象，使得请求的发送者和接收者解耦，可以支持请求的撤销、恢复等操作。\n​\t•\t解释器模式：为语言创建解释器，解释执行用户定义的语言规则。\n​\t•\t迭代器模式：提供一种顺序访问集合元素的方法，而不暴露集合的内部结构。\n​\t•\t中介者模式：通过中介者对象封装对象之间的交互，降低对象之间的耦合度。\n​\t•\t备忘录模式：允许对象恢复到之前的状态，而不暴露对象的内部实现。\n​\t•\t观察者模式：定义对象间的依赖关系，当一个对象状态改变时，通知所有依赖的对象。\n​\t•\t状态模式：允许对象在内部状态改变时改变其行为，适用于状态变化驱动的场景。\n​\t•\t策略模式：定义一系列算法，将每个算法封装起来，并让它们可以相互替换，适用于算法可以变化的场景。\n​\t•\t模板方法模式：定义算法的骨架，将一些步骤延迟到子类中，适用于固定流程但部分步骤可变的场景。\n​\t•\t访问者模式：将操作分离到外部，使得对一组对象的操作可以随着新操作的加入而变化。\n4. 设计模式之间的联系：\n​\t•\t工厂模式和抽象工厂模式经常用于组合对象的创建过程，尤其是当系统具有不同的产品族时，抽象工厂可以与单例模式结合，保证只创建一个产品族的实例。\n​\t•\t适配器模式和外观模式都有简化接口的功能，但适配器模式更多用于使不兼容的接口一起工作，而外观模式则是为了简化一个复杂系统的接口。\n​\t•\t命令模式和责任链模式可以结合使用。命令对象可以沿着责任链传递，直到有处理器能够执行该命令。\n​\t•\t装饰器模式和代理模式都可以用于扩展对象的功能。区别在于，代理模式主要用于控制对对象的访问，而装饰器模式用于动态增加对象的功能。\n​\t•\t状态模式和策略模式的结构非常相似。区别在于，状态模式是对象在不同状态下改变其行为，而策略模式则是根据不同策略选择行为。\n","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/2.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB/","title":"2.1设计模式的概念与分类"},{"content":"[toc]\n二、 面向对象设计原则与UML类图 2.1 面向对象设计7个原则 单一职责原则 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 合成复用原则 迪米特法则 ![image-20241005165935987](/Users/baidongdong/Library/Application Support/typora-user-images/image-20241005165935987.png)\n2.1.1 里氏代换原则 里氏代换原则（Liskov Substitution Principle，LSP） 是面向对象编程中的一种设计原则，要求程序中的子类对象必须能够替换其父类对象，并且保证程序的行为不变。即，子类应该能够替代父类，而不影响程序的正确性。\n在 Python 中，里氏代换原则的应用通常涉及继承和多态性。具体来说，子类应该重写父类的方法时，确保不会改变原有父类方法的行为。\n里氏代换原则的基本要求：\n​\t1.子类必须完全实现父类的方法，不能改变父类原有的方法的功能和行为。\n​\t2.子类可以扩展父类的方法和属性，但不能破坏父类的接口约定。\n举例说明\n示例1：符合里氏代换原则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Animal: def sound(self): raise NotImplementedError(\u0026#34;Subclasses must implement this method\u0026#34;) class Dog(Animal): def sound(self): return \u0026#34;Bark\u0026#34; class Cat(Animal): def sound(self): return \u0026#34;Meow\u0026#34; def make_sound(animal: Animal): print(animal.sound()) # 正确使用，子类可以替代父类 dog = Dog() cat = Cat() make_sound(dog) # 输出: Bark make_sound(cat) # 输出: Meow 解释：\n在这个例子中，Dog 和 Cat 都是 Animal 的子类，它们都实现了 sound 方法，并且遵守了 Animal 的接口规范。 make_sound 函数能够正常处理 Animal 类型的任何子类对象，这正是里氏代换原则的体现：你可以使用父类类型的参数，传递任何其子类对象，而不会影响程序的正确性。\n示例2：违反里氏代换原则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Rectangle: def __init__(self, width, height): self.width = width self.height = height def set_width(self, width): self.width = width def set_height(self, height): self.height = height def area(self): return self.width * self.height class Square(Rectangle): def __init__(self, side): super().__init__(side, side) def set_width(self, width): self.width = width self.height = width # 违反原则，强制修改了 height def set_height(self, height): self.width = height self.height = height # 违反原则，强制修改了 width # 测试代码 def resize_rectangle(rect: Rectangle): rect.set_width(10) rect.set_height(5) print(f\u0026#34;New area: {rect.area()}\u0026#34;) rect = Rectangle(5, 5) resize_rectangle(rect) # 输出：New area: 50 square = Square(5) resize_rectangle(square) # 输出：New area: 25 (应该是50，出现了错误) 解释：\n在这个例子中，Square 继承自 Rectangle，但它在 set_width 和 set_height 方法中修改了父类的方法行为，使得当我们传递 Square 对象给期望 Rectangle 的函数时，行为变得不符合预期。resize_rectangle 函数期望它能自由调整长和宽，但对于 Square 来说，由于长宽必须相等，这导致了不正确的结果。\n修正后的设计\n我们可以通过避免继承来修复这个问题，改用组合（Composition），从而符合里氏代换原则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Rectangle: def __init__(self, width, height): self.width = width self.height = height def set_width(self, width): self.width = width def set_height(self, height): self.height = height def area(self): return self.width * self.height class Square: def __init__(self, side): self.side = side def set_side(self, side): self.side = side def area(self): return self.side * self.side 通过避免继承，Square 不再试图遵循 Rectangle 的接口规范，从而防止违反里氏代换原则。\n总结：\n里氏代换原则要求子类在任何地方都能替代父类对象，不会改变程序的行为。在 Python 的设计中，应该注意子类不要违反父类的接口约定，确保继承关系中的子类能够无缝替代父类。\n2.1.2 依赖倒转原则 依赖倒转原则（Dependency Inversion Principle，DIP） 是面向对象设计中的一项原则，它是 SOLID 原则的五个基本原则之一。依赖倒转原则的核心思想是：\n​\t1.高层模块不应该依赖于低层模块，二者都应该依赖于抽象。\n​\t2.抽象不应该依赖于具体实现，具体实现应该依赖于抽象。\n**简单来说：**程序中的高层模块（逻辑层或业务层）和低层模块（工具层或实现层）都应依赖于抽象，而不是具体的实现。这使得代码更加灵活、可扩展和易维护。\n依赖倒转原则的两个主要规则：\n​\t•高层模块 不应该依赖于 低层模块，而是应该依赖于 接口或抽象类。\n​\t•接口或抽象类 不应该依赖于 实现类，而是实现类依赖于 接口或抽象类。\n依赖倒转原则的好处：\n​\t•提高了模块间的解耦。\n​\t•更容易扩展或修改代码。\n​\t•增强了代码的可测试性。\n如何在 Python 中实现依赖倒转原则\n我们通常通过**依赖注入（Dependency Injection）**的方式来实现依赖倒转，使用接口或抽象类来避免直接依赖具体实现。\n例子说明\n1. 违反依赖倒转原则的实现\n在这个例子中，Keyboard 和 Monitor 是高层模块，而它们直接依赖于具体的 WindowsKeyboard 和 WindowsMonitor 实现。这样会导致代码耦合度高，无法轻易替换不同的键盘或显示器实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class WindowsKeyboard: def input(self): return \u0026#34;Keyboard input from Windows\u0026#34; class WindowsMonitor: def display(self, content): print(f\u0026#34;Displaying on Windows monitor: {content}\u0026#34;) class Computer: def __init__(self): self.keyboard = WindowsKeyboard() self.monitor = WindowsMonitor() def start(self): user_input = self.keyboard.input() self.monitor.display(user_input) # 测试代码 computer = Computer() computer.start() 问题：\n​\t•Computer 类直接依赖于具体的 WindowsKeyboard 和 WindowsMonitor 实现。如果将来需要支持 MacKeyboard 或 MacMonitor，必须修改 Computer 类的代码，违反了依赖倒转原则。\n2. 遵循依赖倒转原则的实现\n我们通过引入接口（或者在 Python 中使用抽象类）来实现依赖倒转，使高层模块和低层模块都依赖于抽象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from abc import ABC, abstractmethod # 抽象类接口定义 class Keyboard(ABC): @abstractmethod def input(self): pass class Monitor(ABC): @abstractmethod def display(self, content): pass # 具体实现类 class WindowsKeyboard(Keyboard): def input(self): return \u0026#34;Keyboard input from Windows\u0026#34; class MacKeyboard(Keyboard): def input(self): return \u0026#34;Keyboard input from Mac\u0026#34; class WindowsMonitor(Monitor): def display(self, content): print(f\u0026#34;Displaying on Windows monitor: {content}\u0026#34;) class MacMonitor(Monitor): def display(self, content): print(f\u0026#34;Displaying on Mac monitor: {content}\u0026#34;) # 高层模块依赖于抽象，而不是具体实现 class Computer: def __init__(self, keyboard: Keyboard, monitor: Monitor): self.keyboard = keyboard self.monitor = monitor def start(self): user_input = self.keyboard.input() self.monitor.display(user_input) # 测试代码 windows_computer = Computer(WindowsKeyboard(), WindowsMonitor()) windows_computer.start() mac_computer = Computer(MacKeyboard(), MacMonitor()) mac_computer.start() 解释：\n​\t• Keyboard 和 Monitor 是抽象类，定义了接口 input() 和 display()，但没有具体实现。\n​\t• WindowsKeyboard 和 MacKeyboard 分别是 Keyboard 的子类，实现了 input() 方法。类似地，WindowsMonitor 和 MacMonitor 是 Monitor 的子类，实现了 display() 方法。\n​\t• Computer 类现在依赖的是 Keyboard 和 Monitor 这两个抽象类，而不是具体的 WindowsKeyboard 或 WindowsMonitor。因此，我们可以灵活地替换不同的键盘和显示器实现，而无需修改 Computer 类的代码。\n好处：\n​\t•\t通过依赖抽象（接口/抽象类）而不是具体实现，Computer 类解耦了对 Keyboard 和 Monitor 具体实现的依赖。\n​\t•\t如果需要增加新的键盘或显示器类型，只需添加相应的类，而不需要修改 Computer 类的代码。\n​\t•\t高层模块 Computer 和低层模块 WindowsKeyboard、MacKeyboard 之间的耦合被打破，增强了系统的可扩展性和灵活性。\n3. 依赖注入（Dependency Injection）\n为了实现依赖倒转原则，通常会使用依赖注入的设计模式。依赖注入有以下几种形式：\n​\t1.\t构造函数注入（Constructor Injection）：依赖通过构造函数传递，如上面的例子中，Computer 的构造函数接收 Keyboard 和 Monitor 作为参数。\n​\t2.\t方法注入（Setter Injection）：依赖通过类的方法传递。\n​\t3.\t接口注入（Interface Injection）：依赖通过接口传递，不过这种方式在 Python 中不常见。\n4. Python 中的依赖倒转与 Duck Typing\nPython 本身是动态类型语言，因此不像 Java 或 C# 那样需要显式地定义接口。虽然我们可以使用 abc 模块定义抽象类，但在某些情况下，我们也可以直接使用鸭子类型（Duck Typing）。只要类实现了相同的方法名，就可以实现类似的效果。\n鸭子类型的实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class WindowsKeyboard: def input(self): return \u0026#34;Keyboard input from Windows\u0026#34; class MacKeyboard: def input(self): return \u0026#34;Keyboard input from Mac\u0026#34; class WindowsMonitor: def display(self, content): print(f\u0026#34;Displaying on Windows monitor: {content}\u0026#34;) class MacMonitor: def display(self, content): print(f\u0026#34;Displaying on Mac monitor: {content}\u0026#34;) # 高层模块依然依赖于抽象（接口） class Computer: def __init__(self, keyboard, monitor): self.keyboard = keyboard self.monitor = monitor def start(self): user_input = self.keyboard.input() self.monitor.display(user_input) # 测试代码 windows_computer = Computer(WindowsKeyboard(), WindowsMonitor()) windows_computer.start() mac_computer = Computer(MacKeyboard(), MacMonitor()) mac_computer.start() 在这个例子中，我们没有显式使用接口或抽象类，而是依靠鸭子类型，假设 Keyboard 和 Monitor 都有 input() 和 display() 方法，依然达到了依赖倒转的效果。\n总结\n​\t•\t依赖倒转原则（DIP） 是面向对象设计的重要原则，旨在通过依赖抽象而不是具体实现来降低耦合度。\n​\t•\t在 Python 中，依赖倒转可以通过抽象类和接口实现，并结合依赖注入（例如通过构造函数注入）来实现解耦。\n​\t•\t鸭子类型可以在动态类型语言如 Python 中实现类似的效果，但在需要明确接口规范时，使用抽象类是一个更安全的选择。\n通过依赖倒转原则，可以使代码更具扩展性、灵活性和可维护性，并且更加容易测试。\n2.1.3 接口隔离原则 ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/2.2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8Euml%E7%B1%BB%E5%9B%BE/","title":"2.2面向对象设计原则与UML类图"},{"content":"在UML中，关联关系通常包含如下几种形式： 一、关联关系 关联（Association）关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。在UML类图中，用实线连接有关联关系的对象所对应的类，在使用Java、C＃和C++等编程语言实现关联关系时，通常将一个类的对象作为另一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示二者之间关系的动词或者名词表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色。因此，在一个关联关系中可以包含两个角色名，角色名不是必需的，可以根据需要增加，其目的是使类之间的关系更加明确。 例如在一个登录界面类LoginForm中包含一个JButton类型的注册按钮loginButton，它们之间可以表示为关联关系。代码实现时可以在LoginForm中定义一个名为loginButton的属性对象，其类型为JButton，如图2-2所示.\n1 双向关联 ![image-20241006184628562](/Users/baidongdong/Library/Application Support/typora-user-images/image-20241006184628562.png)\n2 单向关联 ![image-20241006184701921](/Users/baidongdong/Library/Application Support/typora-user-images/image-20241006184701921.png)\n3 自关联 4 多重性关联 5 聚合关系 聚合关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。例如，汽车发动机（Engine）是汽车（Car）的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系，如图2-7所示。\n6 组合关系 组合（Composition）关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期。一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。例如，人的头（Head）与嘴巴（Mouth），嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系，如图2-8所示。\n二、依赖关系 依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如，驾驶员开车，在Driver类的drive（）方法中将Car类型的对象car作为一个参数传递，以便在drive（）方法中能够调用Car类的move（）方法，且驾驶员的drive（）方法依赖车的move（）方法，因此类Driver依赖类Car，如图2-9所示。\n在系统实施阶段，依赖关系通常通过3种方式来实现：第1种也是最常用的一种方式，是如图2-9所示的将一个类的对象作为另一个类中方法的参数；第2种方式是在一个类的方法中将另一个类的对象作为其局部变量；第3种方式是在一个类的方法中调用另一个类的静态方法。\n三、泛化关系 泛化（Generalization）关系也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。在代码实现时，使用面向对象的继承机制来实现泛化关系，如在Java语言中使用extends关键字、在C++/C＃中使用冒号“：”来实现。例如，Student类和Teacher类都是Person类的子类，Student类和Teacher类继承了Person类的属性和方法，Person类的属性包含姓名（name）和年龄（age），每一个Student和Teacher也都具有这两个属性。另外Student类增加了属性学号（studentNo），Teacher类增加了属性教师编号（teacherNo），Person类的方法包括行走move（）和说话say（），Student类和Teacher类继承了这两个方法，而且Student类还新增方法study（），Teacher类新增方法teach（），如图2-10所示.\n四、接口与实现关系 在很多面向对象语言中都引入了接口的概念，如Java、C＃等。在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。UML中用与类的表示法类似的方式表示接口，如图2-11所示。 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现（Realization）关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。例如，定义了一个交通工具接口Vehicle，包含一个抽象操作move（），在类Ship和类Car中都实现了该move（）操作，不过具体的实现细节将会不一样，如图2-12所示。\n","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/2.3uml%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/","title":"2.3UML类图关系"},{"content":"一、概念 状态模式是说一个对象在其内部状态发生改变时，其表现的行为和外在属性不一样，这个对象看上去就像改变了它的类型一样。因此，状态模式又称为对象的行为模式。\n二、设计思想 状态模式的核心思想就是一个事物（对象）有多种状态，在不同的状态下所表现出来的行为和属性不一样.\n三、类图 State是抽象状态类（基类），负责状态的定义和接口的统一。StateA和StateB是具体的状态类，如故事剧情中的SolidState、LiquidState 、GaseousState。Context是上下文环境类，负责具体状态的切换\n四、模型说明 1.设计要点 （1）在实现状态模式的时候，实现的场景状态有时候会非常复杂，决定状态变化的因素也非常多，我们可以把决定状态变化的属性单独抽象成一个类 StateInfo，这样判断状态属性是否符合当前的状态isMatch时就可以传入更多的信息。 （2）每一种状态应当只有唯一的实例,使用单例模式。 2.状态模式的优缺点 优点： （1）封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类中，对状态转换代码进行集中管理，而不是分散在一个个业务逻辑中。 （2）将所有与某个状态有关的行为放到一个类中（称为状态类），使开发人员只专注于该状态下的逻辑开发。 （3）允许状态转换逻辑与状态对象合为一体，使用时只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。 缺点： （1）会增加系统类和对象的个数。 （2）状态模式的结构与实现都较为复杂，如果使用不当容易导致程序结构和代码的混乱。\n五、应用说明 （1）一个对象的行为取决于它的状态，并且它在运行时可能经常改变它的状态，从而改变它的行为。 （2）一个操作中含有庞大的多分支的条件语句，这些分支依赖于该对象的状态，且每一个分支的业务逻辑都非常复杂时，我们可以使用状态模式来拆分不同的分支逻辑，使程序有更好的可读性和可维护性。\n六、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 # Version 2.0 ######################################################################################################################## from abc import ABCMeta, abstractmethod # 引入ABCMeta和abstractmethod来定义抽象类和抽象方法 class Context(metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;状态模式的上下文环境类\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.__states = [] self.__curState = None # 状态发生变化依赖的属性, 当这一变量由多个变量共同决定时可以将其单独定义成一个类 self.__stateInfo = 0 def addState(self, state): if (state not in self.__states): self.__states.append(state) def changeState(self, state): if (state is None): return False if (self.__curState is None): print(\u0026#34;初始化为\u0026#34;, state.getName()) else: print(\u0026#34;由\u0026#34;, self.__curState.getName(), \u0026#34;变为\u0026#34;, state.getName()) self.__curState = state self.addState(state) return True def getState(self): return self.__curState def _setStateInfo(self, stateInfo): self.__stateInfo = stateInfo for state in self.__states: if( state.isMatch(stateInfo) ): self.changeState(state) def _getStateInfo(self): return self.__stateInfo class State: \u0026#34;\u0026#34;\u0026#34;状态的基类\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.__name = name def getName(self): return self.__name def isMatch(self, stateInfo): \u0026#34;状态的属性stateInfo是否在当前的状态范围内\u0026#34; return False @abstractmethod def behavior(self, context): pass # Demo 实现 class Water(Context): \u0026#34;\u0026#34;\u0026#34;水(H2O)\u0026#34;\u0026#34;\u0026#34; def __init__(self): super().__init__() self.addState(SolidState(\u0026#34;固态\u0026#34;)) self.addState(LiquidState(\u0026#34;液态\u0026#34;)) self.addState(GaseousState(\u0026#34;气态\u0026#34;)) self.setTemperature(25) def getTemperature(self): return self._getStateInfo() def setTemperature(self, temperature): self._setStateInfo(temperature) def riseTemperature(self, step): self.setTemperature(self.getTemperature() + step) def reduceTemperature(self, step): self.setTemperature(self.getTemperature() - step) def behavior(self): state = self.getState() if(isinstance(state, State)): state.behavior(self) # 单例的装饰器 def singleton(cls, *args, **kwargs): \u0026#34;构造一个单例的装饰器\u0026#34; instance = {} def __singleton(*args, **kwargs): if cls not in instance: instance[cls] = cls(*args, **kwargs) return instance[cls] return __singleton @singleton class SolidState(State): \u0026#34;\u0026#34;\u0026#34;固态\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): super().__init__(name) def isMatch(self, stateInfo): return stateInfo \u0026lt; 0 def behavior(self, context): print(\u0026#34;我性格高冷，当前体温\u0026#34;, context._getStateInfo(), \u0026#34;℃，我坚如钢铁，仿如一冷血动物，请用我砸人，嘿嘿……\u0026#34;) @singleton class LiquidState(State): \u0026#34;\u0026#34;\u0026#34;液态\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): super().__init__(name) def isMatch(self, stateInfo): return (stateInfo \u0026gt;= 0 and stateInfo \u0026lt; 100) def behavior(self, context): print(\u0026#34;我性格温和，当前体温\u0026#34;, context._getStateInfo(), \u0026#34;℃，我可滋润万物，饮用我可让你活力倍增……\u0026#34;) @singleton class GaseousState(State): \u0026#34;\u0026#34;\u0026#34;气态\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): super().__init__(name) def isMatch(self, stateInfo): return stateInfo \u0026gt;= 100 def behavior(self, context): print(\u0026#34;我性格热烈，当前体温\u0026#34;, context._getStateInfo(), \u0026#34;℃，飞向天空是我毕生的梦想，在这你将看不到我的存在，我将达到无我的境界……\u0026#34;) # Test ######################################################################################################################## def testState(): # water = Water(LiquidState(\u0026#34;液态\u0026#34;)) water = Water() water.behavior() water.setTemperature(-4) water.behavior() water.riseTemperature(18) water.behavior() water.riseTemperature(110) water.behavior() testState() ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/3.1%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","title":"3.1状态模式"},{"content":"一、概念 Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently. 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介模式又称为调停模式。\n二、设计思想 在很多系统中，多个类很容易相互耦合，形成网状结构。中介模式的作用就是将这种网状结构（如图3-3所示）分离成星型结构（如图3-4所示）。这样调整之后，使得对象间的结构更加简洁，交互更加顺畅。\n三、类图 Mediator 就是中介类，用来协调对象间的交互，如故事剧情中的 HousingAgency。中介类可以有多个具体实现类，如MediatorImplA和MediatorImplB。InteractiveObject是要进行交互的对象，如故事剧情中的HouseOwner和Customer。InteractiveObject可以是互不相干的多个类的对象，也可以是具有继承关系的相似类\n四、模型说明 1.设计要点 中介模式主要有以下三个角色，在设计中介模式时要找到并区分这些角色： （1）交互对象（InteractiveObject）：要进行交互的一系列对象。 （2）中介者（Mediator）：负责协调各个对象之间的交互。 （3）具体中介者（Mediator）：中介的具体实现。 2.中介模式的优缺点 优点： （1）Mediator 将原本分布于多个对象间的行为集中在一起，作为一个独立的概念并将其封装在一个对象中，简化了对象之间的交互。 （2）将多个调用者与多个实现者之间多对多的交互关系，转换为一对多的交互关系，一对多的交互关系更易于理解、维护和扩展，大大减少了多个对象之间相互交叉引用的情况。 通过中介找房子给我们带来了很多的便利，但也存在诸多明显问题： （1）很容易遇到黑中介（比如各种不规范和坑，也许你正深陷其中）。 （2）高昂的中介费（给本就受伤的心灵又多补了一刀）。 中介模式也有很多缺点： （1）中介者承接了所有的交互逻辑，交互的复杂度转变成了中介者的复杂度，中介者类会变得越来越庞大和复杂，以至于难以维护。 （2）中介者出问题会导致多个使用者同时出问题。\n五、应用说明 （1）一组对象以定义良好但复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。 （2）一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。 （3）想通过一个中间类来封装多个类中的行为，同时又不想生成太多的子类。\n六、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 # Version 2.0 #======================================================================================================================= # 代码框架 #============================== class InteractiveObject: \u0026#34;\u0026#34;\u0026#34;进行交互的对象\u0026#34;\u0026#34;\u0026#34; pass class InteractiveObjectImplA: \u0026#34;\u0026#34;\u0026#34;实现类A\u0026#34;\u0026#34;\u0026#34; pass class InteractiveObjectImplB: \u0026#34;\u0026#34;\u0026#34;实现类B\u0026#34;\u0026#34;\u0026#34; pass class Meditor: \u0026#34;\u0026#34;\u0026#34;中介类\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.__interactiveObjA = InteractiveObjectImplA() self.__interactiveObjB = InteractiveObjectImplB() def interative(self): \u0026#34;\u0026#34;\u0026#34;进行交互的操作\u0026#34;\u0026#34;\u0026#34; # 通过self.__interactiveObjA和self.__interactiveObjB完成相应的交互操作 pass # 基于框架的实现 #============================== from abc import ABCMeta, abstractmethod # 引入ABCMeta和abstractmethod来定义抽象类和抽象方法 from enum import Enum # Python3.4 之后支持枚举Enum的语法 class DeviceType(Enum): \u0026#34;设备类型\u0026#34; TypeSpeaker = 1 TypeMicrophone = 2 TypeCamera = 3 class DeviceItem: \u0026#34;\u0026#34;\u0026#34;设备项\u0026#34;\u0026#34;\u0026#34; def __init__(self, id, name, type, isDefault = False): self.__id = id self.__name = name self.__type = type self.__isDefault = isDefault def __str__(self): return \u0026#34;type:\u0026#34; + str(self.__type) + \u0026#34; id:\u0026#34; + str(self.__id) \\ + \u0026#34; name:\u0026#34; + str(self.__name) + \u0026#34; isDefault:\u0026#34; + str(self.__isDefault) def getId(self): return self.__id def getName(self): return self.__name def getType(self): return self.__type def isDefault(self): return self.__isDefault class DeviceList: \u0026#34;\u0026#34;\u0026#34;设备列表\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.__devices = [] def add(self, deviceItem): self.__devices.append(deviceItem) def getCount(self): return len(self.__devices) def getByIdx(self, idx): if idx \u0026lt; 0 or idx \u0026gt;= self.getCount(): return None return self.__devices[idx] def getById(self, id): for item in self.__devices: if( item.getId() == id): return item return None class DeviceMgr(metaclass=ABCMeta): @abstractmethod def enumerate(self): \u0026#34;\u0026#34;\u0026#34;枚举设备列表 (在程序初始化时，有设备插拔时都要重新获取设备列表)\u0026#34;\u0026#34;\u0026#34; pass @abstractmethod def active(self, deviceId): \u0026#34;\u0026#34;\u0026#34;选择要使用的设备\u0026#34;\u0026#34;\u0026#34; pass @abstractmethod def getCurDeviceId(self): \u0026#34;\u0026#34;\u0026#34;获取当前正在使用的设计ID\u0026#34;\u0026#34;\u0026#34; pass class SpeakerMgr(DeviceMgr): \u0026#34;\u0026#34;\u0026#34;扬声器设备管理类\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.__curDeviceId = None def enumerate(self): \u0026#34;\u0026#34;\u0026#34;枚举设备列表 (真实的项目应该通过驱动程序去读取设备信息，这里只用初始化来模拟)\u0026#34;\u0026#34;\u0026#34; devices = DeviceList() devices.add(DeviceItem(\u0026#34;369dd760-893b-4fe0-89b1-671eca0f0224\u0026#34;, \u0026#34;Realtek High Definition Audio\u0026#34;, DeviceType.TypeSpeaker)) devices.add(DeviceItem(\u0026#34;59357639-6a43-4b79-8184-f79aed9a0dfc\u0026#34;, \u0026#34;NVIDIA High Definition Audio\u0026#34;, DeviceType.TypeSpeaker, True)) return devices def active(self, deviceId): \u0026#34;\u0026#34;\u0026#34;激活指定的设备作为当前要用的设备\u0026#34;\u0026#34;\u0026#34; self.__curDeviceId = deviceId def getCurDeviceId(self): return self.__curDeviceId class DeviceUtil: \u0026#34;\u0026#34;\u0026#34;设备工具类\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.__mgrs = {} self.__mgrs[DeviceType.TypeSpeaker] = SpeakerMgr() # 为节省篇幅，MicrophoneMgr和CameraMgr不再实现 # self.__microphoneMgr = MicrophoneMgr() # self.__cameraMgr = CameraMgr def __getDeviceMgr(self, type): return self.__mgrs[type] def getDeviceList(self, type): return self.__getDeviceMgr(type).enumerate() def active(self, type, deviceId): self.__getDeviceMgr(type).active(deviceId) def getCurDeviceId(self, type): return self.__getDeviceMgr(type).getCurDeviceId() # Test #======================================================================================================================= def testRenting(): myHome = HousingAgency(\u0026#34;我爱我家\u0026#34;) zhangsan = HouseOwner(\u0026#34;张三\u0026#34;); zhangsan.setHouseInfo(\u0026#34;上地西里\u0026#34;, 20, 2500, 1, \u0026#34;独立卫生间\u0026#34;, 0) zhangsan.publishHouseInfo(myHome) lisi = HouseOwner(\u0026#34;李四\u0026#34;) lisi.setHouseInfo(\u0026#34;当代城市家园\u0026#34;, 16, 1800, 1, \u0026#34;公用卫生间\u0026#34;, 0) lisi.publishHouseInfo(myHome) wangwu = HouseOwner(\u0026#34;王五\u0026#34;) wangwu.setHouseInfo(\u0026#34;金隅美和园\u0026#34;, 18, 2600, 1, \u0026#34;独立卫生间\u0026#34;, 1) wangwu.publishHouseInfo(myHome) print() myHome.signContracts(3) print() tony = Customer(\u0026#34;Tony\u0026#34;) houseInfos = tony.findHouse(\u0026#34;18平米左右，要有独卫，要有窗户，最好是朝南，有厨房更好！价位在2000左右\u0026#34;, myHome) print() print(\u0026#34;正在看房，寻找最合适的住巢……\u0026#34;) print() AppropriateHouse = tony.seeHouse(houseInfos) tony.signContract(AppropriateHouse, myHome, 1) def testDevices(): deviceUtil = DeviceUtil() deviceList = deviceUtil.getDeviceList(DeviceType.TypeSpeaker) print(\u0026#34;麦克风设备列表：\u0026#34;) if deviceList.getCount() \u0026gt; 0: # 设置第一个设备为要用的设备 deviceUtil.active(DeviceType.TypeSpeaker, deviceList.getByIdx(0).getId()) for idx in range(0, deviceList.getCount()): device = deviceList.getByIdx(idx) print(device) print(\u0026#34;当前使用的设备：\u0026#34; + deviceList.getById(deviceUtil.getCurDeviceId(DeviceType.TypeSpeaker)).getName()) # testRenting() testDevices() ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/3.2%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","title":"3.2中介模式"},{"content":"一、概念 Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it. 为避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求。将这些接收对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 职责模式也称为责任链模式，它将请求的发送者和接收者解耦了。客户端不需要知道请求处理者的明确信息和处理的具体逻辑，甚至不需要知道链的结构，它只需要将请求进行发送即可\n二、设计思想 链条上的每一个人只处理自己职责范围内的请求，对于自己处理不了的请求，直接交给下一个责任人。这就是程序设计中职责模式的核心思想。\n在职责模式中我们可以随时随地增加或者更改责任人，甚至可以更改责任人的顺序，增加了系统的灵活性。但是有时候可能会导致一个请求无论如何也得不到处理，它会被放置在链条末端。\n三、类图 Requester 是请求的发送者，如故事剧情中的 Person。Request 是请求的包装类，封装一个请求对象。Responsible是责任人的抽象基类，也是责任链的节点；Responsible中有一个指向自身的引用，也就是下一个责任人，这是责任链形成的关键。ResponsiblePersonA 和ResponsiblePersonB是具体的责任人，如故事剧情中的直属领导、部门总监、CEO等\n四、代码框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 from abc import ABCMeta, abstractmethod # 引入ABCMeta和abstractmethod来定义抽象类和抽象方法 class Request: \u0026#34;\u0026#34;\u0026#34;请求(内容)\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, dayoff, reason): self.__name = name self.__dayoff = dayoff self.__reason = reason self.__leader = None def getName(self): return self.__name def getDayOff(self): return self.__dayoff def getReason(self): return self.__reason class Responsible(metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;责任人抽象类\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, title): self.__name = name self.__title = title self._nextHandler = None def getName(self): return self.__name def getTitle(self): return self.__title def setNextHandler(self, nextHandler): self._nextHandler = nextHandler def getNextHandler(self): return self._nextHandler def handleRequest(self, request): \u0026#34;\u0026#34;\u0026#34;请求处理\u0026#34;\u0026#34;\u0026#34; # 当前责任人处理请求 self._handleRequestImpl(request) # 如果存在下一个责任人，则将请求传递(提交)给下一个责任人 if (self._nextHandler is not None): self._nextHandler.handleRequest(request) @abstractmethod def _handleRequestImpl(self, request): \u0026#34;\u0026#34;\u0026#34;真正处理请求的方法\u0026#34;\u0026#34;\u0026#34; pass 五、模型说明 1.设计要点 在设计职责模式的程序时要注意以下几点。 （1）请求者与请求内容：确认谁要发送请求，发送请求的对象称为请求者。请求的内容通过发送请求时的参数进行传递。 （2）有哪些责任人：责任人是构成责任链的关键要素。请求的流动方向是链条中的线，而责任人则是链条上的节点，线和节点共同构成了一条链条。 （3）对责任人进行抽象：真实世界中的责任人多种多样，纷繁复杂，有不同的职责和功能；但他们也有一个共同的特征—都可以处理请求。所以需要对责任人进行抽象，使他们具有责任的可传递性。 （4）责任人可自由组合：责任链上的责任人可以根据业务的具体逻辑进行自由的组合和排序。 2.职责模式的优缺点 优点： （1）降低耦合度。它将请求的发送者和接收者解耦。 （2）简化了对象。它使得对象不需要知道链的结构。 （3）增强给对象指派职责的灵活性。可改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任人。 （4）增加新的处理类很方便。 缺点： （1）不能保证请求一定被接收。 （2）系统性能将受到一定的影响，而且在进行代码调试时不太方便，可能会造成循环调用。\n六、应用说明 （1）有多个对象可以处理同一个请求，具体哪个对象处理该请求在运行时刻自动确定。 （2）请求的处理具有明显的一层层传递关系。 （3）请求的处理流程和顺序需要程序运行时动态确定。 （4）常见的审批流程（账务报销、转岗申请等）。\n七、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 ##!/usr/bin/python # Version 1.0 ######################################################################################################################## # from abc import ABCMeta, abstractmethod # # 引入ABCMeta和abstractmethod来定义抽象类和抽象方法 # # class Person: # \u0026#34;\u0026#34;\u0026#34;请假申请人\u0026#34;\u0026#34;\u0026#34; # def __init__(self, name, dayoff, reason): # self.__name = name # self.__dayoff = dayoff # self.__reason = reason # self.__leader = None # # def getName(self): # return self.__name # # def getDayOff(self): # return self.__dayoff # # def getReason(self): # return self.__reason # # def setLeader(self, leader): # self.__leader = leader # # def reuqest(self): # print(\u0026#34;%s 申请请假 %d 天。请假事由：%s\u0026#34; % (self.__name, self.__dayoff, self.__reason) ) # if( self.__leader is not None): # self.__leader.handleRequest(self) # # # class Manager(metaclass=ABCMeta): # \u0026#34;\u0026#34;\u0026#34;公司管理人员\u0026#34;\u0026#34;\u0026#34; # # def __init__(self, name, title): # self.__name = name # self.__title = title # self._nextHandler = None # # def getName(self): # return self.__name # # def getTitle(self): # return self.__title # # def setNextHandler(self, nextHandler): # self._nextHandler = nextHandler # # @abstractmethod # def handleRequest(self, person): # pass # # class Supervisor(Manager): # \u0026#34;\u0026#34;\u0026#34;主管\u0026#34;\u0026#34;\u0026#34; # # def __init__(self, name, title): # super().__init__(name, title) # # def handleRequest(self, person): # if(person.getDayOff() \u0026lt;= 2): # print(\u0026#34;同意 %s 请假，签字人：%s(%s)\u0026#34; % (person.getName(), self.getName(), self.getTitle()) ) # if(self._nextHandler is not None): # self._nextHandler.handleRequest(person) # # # class DepartmentManager(Manager): # \u0026#34;\u0026#34;\u0026#34;部门总监\u0026#34;\u0026#34;\u0026#34; # def __init__(self, name, title): # super().__init__(name, title) # # def handleRequest(self, person): # if(person.getDayOff() \u0026gt;2 and person.getDayOff() \u0026lt;= 5): # print(\u0026#34;同意 %s 请假，签字人：%s(%s)\u0026#34; % (person.getName(), self.getName(), self.getTitle())) # if(self._nextHandler is not None): # self._nextHandler.handleRequest(person) # # class CEO(Manager): # \u0026#34;\u0026#34;\u0026#34;CEO\u0026#34;\u0026#34;\u0026#34; # # def __init__(self, name, title): # super().__init__(name, title) # # def handleRequest(self, person): # if (person.getDayOff() \u0026gt; 5 and person.getDayOff() \u0026lt;= 22): # print(\u0026#34;同意 %s 请假，签字人：%s(%s)\u0026#34; % (person.getName(), self.getName(), self.getTitle())) # # if (self._nextHandler is not None): # self._nextHandler.handleRequest(person) # # class Administrator(Manager): # \u0026#34;\u0026#34;\u0026#34;行政人员\u0026#34;\u0026#34;\u0026#34; # # def __init__(self, name, title): # super().__init__(name, title) # # def handleRequest(self, person): # print(\u0026#34;%s 的请假申请已审核，情况属实！已备案处理。处理人：%s(%s)\\n\u0026#34; % (person.getName(), self.getName(), self.getTitle())) # Version 2.0 ######################################################################################################################## # 代码框架 ################## from abc import ABCMeta, abstractmethod # 引入ABCMeta和abstractmethod来定义抽象类和抽象方法 class Request: \u0026#34;\u0026#34;\u0026#34;请求(内容)\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, dayoff, reason): self.__name = name self.__dayoff = dayoff self.__reason = reason self.__leader = None def getName(self): return self.__name def getDayOff(self): return self.__dayoff def getReason(self): return self.__reason class Responsible(metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;责任人抽象类\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, title): self.__name = name self.__title = title self._nextHandler = None def getName(self): return self.__name def getTitle(self): return self.__title def setNextHandler(self, nextHandler): self._nextHandler = nextHandler def getNextHandler(self): return self._nextHandler def handleRequest(self, request): \u0026#34;\u0026#34;\u0026#34;请求处理\u0026#34;\u0026#34;\u0026#34; # 当前责任人处理请求 self._handleRequestImpl(request) # 如果存在下一个责任人，则将请求传递(提交)给下一个责任人 if (self._nextHandler is not None): self._nextHandler.handleRequest(request) @abstractmethod def _handleRequestImpl(self, request): \u0026#34;\u0026#34;\u0026#34;真正处理请求的方法\u0026#34;\u0026#34;\u0026#34; pass # 基于框架的实现 ################## class Person: \u0026#34;\u0026#34;\u0026#34;请求者(请假人)\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.__name = name self.__leader = None def setName(self, name): self.__name = name def getName(self): return self.__name def setLeader(self, leader): self.__leader = leader def getLeader(self): return self.__leader def sendReuqest(self, request): print(\u0026#34;%s 申请请假 %d 天。请假事由：%s\u0026#34; % (self.__name, request.getDayOff(), request.getReason())) if (self.__leader is not None): self.__leader.handleRequest(request) class Supervisor(Responsible): \u0026#34;\u0026#34;\u0026#34;主管\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, title): super().__init__(name, title) def _handleRequestImpl(self, request): if (request.getDayOff() \u0026lt;= 2): print(\u0026#34;同意 %s 请假，签字人：%s(%s)\u0026#34; % (request.getName(), self.getName(), self.getTitle())) class DepartmentManager(Responsible): \u0026#34;\u0026#34;\u0026#34;部门总监\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, title): super().__init__(name, title) def _handleRequestImpl(self, request): if (request.getDayOff() \u0026gt; 2 and request.getDayOff() \u0026lt;= 5): print(\u0026#34;同意 %s 请假，签字人：%s(%s)\u0026#34; % (request.getName(), self.getName(), self.getTitle())) class CEO(Responsible): \u0026#34;\u0026#34;\u0026#34;CEO\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, title): super().__init__(name, title) def _handleRequestImpl(self, request): if (request.getDayOff() \u0026gt; 5 and request.getDayOff() \u0026lt;= 22): print(\u0026#34;同意 %s 请假，签字人：%s(%s)\u0026#34; % (request.getName(), self.getName(), self.getTitle())) class Administrator(Responsible): \u0026#34;\u0026#34;\u0026#34;行政人员\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, title): super().__init__(name, title) def _handleRequestImpl(self, request): print(\u0026#34;%s 的请假申请已审核，情况属实！已备案处理。处理人：%s(%s)\\n\u0026#34; % (request.getName(), self.getName(), self.getTitle())) # Test ######################################################################################################################## # def testAskForLeave(): # directLeader = Supervisor(\u0026#34;Eren\u0026#34;, \u0026#34;客户端研发部经理\u0026#34;) # departmentLeader = DepartmentManager(\u0026#34;Eric\u0026#34;, \u0026#34;技术研发中心总监\u0026#34;) # ceo = CEO(\u0026#34;Helen\u0026#34;, \u0026#34;创新文化公司CEO\u0026#34;) # administrator = Administrator(\u0026#34;Nina\u0026#34;, \u0026#34;行政中心总监\u0026#34;) # directLeader.setNextHandler(departmentLeader) # departmentLeader.setNextHandler(ceo) # ceo.setNextHandler(administrator) # # sunny = Person(\u0026#34;Sunny\u0026#34;, 1, \u0026#34;参加MDCC大会。\u0026#34;) # sunny.setLeader(directLeader) # sunny.reuqest() # tony = Person(\u0026#34;Tony\u0026#34;, 5, \u0026#34;家里有紧急事情！\u0026#34;) # tony.setLeader(directLeader) # tony.reuqest() # pony = Person(\u0026#34;Pony\u0026#34;, 15, \u0026#34;出国深造。\u0026#34;) # pony.setLeader(directLeader) # pony.reuqest() def testChainOfResponsibility(): directLeader = Supervisor(\u0026#34;Eren\u0026#34;, \u0026#34;客户端研发部经理\u0026#34;) departmentLeader = DepartmentManager(\u0026#34;Eric\u0026#34;, \u0026#34;技术研发中心总监\u0026#34;) ceo = CEO(\u0026#34;Helen\u0026#34;, \u0026#34;创新文化公司CEO\u0026#34;) administrator = Administrator(\u0026#34;Nina\u0026#34;, \u0026#34;行政中心总监\u0026#34;) directLeader.setNextHandler(departmentLeader) departmentLeader.setNextHandler(ceo) ceo.setNextHandler(administrator) sunny = Person(\u0026#34;Sunny\u0026#34;) sunny.setLeader(directLeader) sunny.sendReuqest(Request(sunny.getName(), 1, \u0026#34;参加MDCC大会。\u0026#34;)) tony = Person(\u0026#34;Tony\u0026#34;) tony.setLeader(directLeader) tony.sendReuqest(Request(tony.getName(), 5, \u0026#34;家里有紧急事情！\u0026#34;)) pony = Person(\u0026#34;Pony\u0026#34;) pony.setLeader(directLeader) pony.sendReuqest(Request(pony.getName(), 15, \u0026#34;出国深造。\u0026#34;)) # testAskForLeave() testChainOfResponsibility() ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/3.3%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","title":"3.3责任链模式"},{"content":" 在软件开发中，有时也存在类似这种不兼容的情况，也可以像引入一个电源适配器一样引入一个被称为适配器的角色来协调这些存在不兼容的结构，这种设计方案即为适配器模式。本章将介绍第一个结构型模式——适配器模式。\n一、适配器模式概述 ​\t在适配器模式中引入了一个被称为适配器（Adapter）的包装类，而它所包装的对象称为适配者（Adaptee），即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。 适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。适配器模式定义如下： 适配器模式（Adapter Pattern）：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n：在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者一组方法的集合。 在适配器模式中，通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器模式和类适配器模式两种。在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器模式的使用频率更高，其结构如图9-3所示\n由图9-3可以看出，在对象适配器模式结构图中包含以下3个角色。 （1）Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 （2）Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器类是适配器模式的核心，在对象适配器模式中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 （3）Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配。适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。\n","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/4.1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"4.1适配器模式"},{"content":"一、概念 Ensure a class has only one instance,and provide a global point of access to it. 确保一个类只有一个实例，并且提供一个访问它的全局方法。\n二、设计思想 单例模式就是保证一个类有且只有一个对象（实例）的一种机制。单例模式用来控制某些事物只允许有一个个体，比如在我们生活的世界中，有生命的星球只有一个—地球（至少到目前为止在人类所探索到的世界中是这样的）。\n三、代码框架 单例模式的实现方式有很多种，下面列出几种常见的方式。 1.重写__new__和__init__方法\n在Python 3的类中，__new__负责对象的创建，而__init__负责对象的初始化；__new__是一个类方法，而__init__是一个对象方法。 __new__是我们通过类名进行实例化对象时自动调用的，__init__是在每一次实例化对象之后调用的，__new__方法创建一个实例之后返回这个实例的对象，并将其传递给__init__方法的self参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Singleton1(object): \u0026#34;\u0026#34;\u0026#34;单例实现方式一\u0026#34;\u0026#34;\u0026#34; __instance = None __isFirstInit = False def __new__(cls, name): if not cls.__instance: Singleton1.__instance = super().__new__(cls) return cls.__instance def __init__(self, name): if not self.__isFirstInit: self.__name = name Singleton1.__isFirstInit = True def getName(self): return self.__name 在上面的示例代码中，我们定义了一个静态的__instance 类变量，用来存放Singleton1的对象，__new__方法每次返回同一个__instance 对象（若未初始化，则进行初始化）。因为每一次通过 s=Singleton1（）的方式创建对象时，都会自动调用__init__方法来初始化实例对象，因此__isFirstInit 的作用就是确保只对__instance 对象进行一次初始化。故事剧情中的代码就是用这种方式实现的单例模式。 在Java和C++这种静态语言中，实现单例模式的一个最简单的方法就是：将构造函数声明成private类型的，再定义一个getInstance（）的静态方法返回一个对象，并确保getInstance（）每次返回同一个对象即可。例如下面的Java示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Singleton { private static Singleton instance = null; private String name; private Singleton(String name) { this.name = name; } public static Singleton getInstance(String name) { if (instance == null) { instance = new Singleton(name); } return instance; } } Python中__new__和__init__都是public类型的，所以我们需要通过重写__new__和__init__方法来改造对象的创建，从而实现单例模式。如果你想更详细地了解Python中__new__和__init__的原理和用法，请参见“附录A Python中__new__和__init__、__call__的用法”。\n2.自定义metaclass的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Singleton2(type): \u0026#34;\u0026#34;\u0026#34;单例实现方式二\u0026#34;\u0026#34;\u0026#34; def __init__(cls, what, bases=None, dict=None): super().__init__(what, bases, dict) cls._instance = None # 初始化全局变量cls._instance为None def __call__(cls, *args, **kwargs): # 控制对象的创建过程，如果cls._instance为None则创建，否则直接返回 if cls._instance is None: cls._instance = super().__call__(*args, **kwargs) return cls._instance class CustomClass(metaclass=Singleton2): \u0026#34;\u0026#34;\u0026#34;用户自定义的类\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.__name = name def getName(self): return self.__name 3.装饰器的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 方式三 #======================================================================================== def singletonDecorator(cls, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;定义一个单例装饰器\u0026#34;\u0026#34;\u0026#34; instance = {} def wrapperSingleton(*args, **kwargs): if cls not in instance: instance[cls] = cls(*args, **kwargs) return instance[cls] return wrapperSingleton @singletonDecorator class Singleton3: \u0026#34;\u0026#34;\u0026#34;使用单例装饰器修饰一个类\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.__name = name def getName(self): return self.__name 四、模型说明 五、应用说明 （1）你希望这个类只有一个且只能有一个实例。 （2）项目中的一些全局管理类（Manager）可以用单例模式来实现。\n六、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 ##!/usr/bin/python # Version 1.0 ######################################################################################################################## class MyBeautifulGril(object): \u0026#34;\u0026#34;\u0026#34;我的漂亮女神\u0026#34;\u0026#34;\u0026#34; __instance = None __isFirstInit = False def __new__(cls, name): if not cls.__instance: MyBeautifulGril.__instance = super().__new__(cls) return cls.__instance def __init__(self, name): if not self.__isFirstInit: self.__name = name print(\u0026#34;遇见\u0026#34; + name + \u0026#34;，我一见钟情！\u0026#34;) MyBeautifulGril.__isFirstInit = True else: print(\u0026#34;遇见\u0026#34; + name + \u0026#34;，我置若罔闻！\u0026#34;) def showMyHeart(self): print(self.__name + \u0026#34;就我心中的唯一！\u0026#34;) # 各种singleton实现方式 ######################################################################################################################## # class Singleton1(object): # \u0026#34;\u0026#34;\u0026#34;单例实现方式一\u0026#34;\u0026#34;\u0026#34; # __instance = None # __isFirstInit = False # # def __new__(cls, name): # if not cls.__instance: # Singleton1.__instance = super().__new__(cls) # return cls.__instance # # def __init__(self, name): # if not self.__isFirstInit: # self.__name = name # Singleton1.__isFirstInit = True # # def getName(self): # return self.__name # # # Test # tony = Singleton1(\u0026#34;Tony\u0026#34;) # karry = Singleton1(\u0026#34;Karry\u0026#34;) # print(tony.getName(), karry.getName()) # print(\u0026#34;id(tony):\u0026#34;, id(tony), \u0026#34;id(karry):\u0026#34;, id(karry)) # print(\u0026#34;tony == karry:\u0026#34;, tony == karry) # 方式二 #======================================================================================== # class Singleton2(type): # \u0026#34;\u0026#34;\u0026#34;单例实现方式二\u0026#34;\u0026#34;\u0026#34; # # def __init__(cls, what, bases=None, dict=None): # super().__init__(what, bases, dict) # cls._instance = None # 初始化全局变量cls._instance为None # # def __call__(cls, *args, **kwargs): # # 控制对象的创建过程，如果cls._instance为None则创建，否则直接返回 # if cls._instance is None: # cls._instance = super().__call__(*args, **kwargs) # return cls._instance # # class CustomClass(metaclass=Singleton2): # \u0026#34;\u0026#34;\u0026#34;用户自定义的类\u0026#34;\u0026#34;\u0026#34; # # def __init__(self, name): # self.__name = name # # def getName(self): # return self.__name # # # tony = CustomClass(\u0026#34;Tony\u0026#34;) # karry = CustomClass(\u0026#34;Karry\u0026#34;) # print(tony.getName(), karry.getName()) # print(\u0026#34;id(tony):\u0026#34;, id(tony), \u0026#34;id(karry):\u0026#34;, id(karry)) # print(\u0026#34;tony == karry:\u0026#34;, tony == karry) # 方式三 #======================================================================================== def singletonDecorator(cls, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;定义一个单例装饰器\u0026#34;\u0026#34;\u0026#34; instance = {} def wrapperSingleton(*args, **kwargs): if cls not in instance: instance[cls] = cls(*args, **kwargs) return instance[cls] return wrapperSingleton @singletonDecorator class Singleton3: \u0026#34;\u0026#34;\u0026#34;使用单例装饰器修饰一个类\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.__name = name def getName(self): return self.__name # tony = Singleton3(\u0026#34;Tony\u0026#34;) # karry = Singleton3(\u0026#34;Karry\u0026#34;) # print(tony.getName(), karry.getName()) # print(\u0026#34;id(tony):\u0026#34;, id(tony), \u0026#34;id(karry):\u0026#34;, id(karry)) # print(\u0026#34;tony == karry:\u0026#34;, tony == karry) # Version 2.0 ######################################################################################################################## @singletonDecorator class MyBeautifulGril(object): \u0026#34;\u0026#34;\u0026#34;我的漂亮女神\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.__name = name if self.__name == name: print(\u0026#34;遇见\u0026#34; + name + \u0026#34;，我一见钟情！\u0026#34;) else: print(\u0026#34;遇见\u0026#34; + name + \u0026#34;，我置若罔闻！\u0026#34;) def showMyHeart(self): print(self.__name + \u0026#34;就我心中的唯一！\u0026#34;) # Test ######################################################################################################################## def TestLove(): jenny = MyBeautifulGril(\u0026#34;Jenny\u0026#34;) jenny.showMyHeart() kimi = MyBeautifulGril(\u0026#34;Kimi\u0026#34;) kimi.showMyHeart() print(\u0026#34;id(jenny):\u0026#34;, id(jenny), \u0026#34; id(kimi):\u0026#34;, id(kimi)) TestLove() ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/4.2%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"4.2单例模式"},{"content":"一、概念 Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype. 用原型实例指定要创建对象的种类，并通过拷贝这些原型的属性来创建新的对象。 通过拷贝自身的属性来创建一个新对象的过程叫作克隆模式（Clone）。在很多书籍和资料中被称为原型模式，但我觉得克隆一词更能切中其主旨。 克隆模式的核心就是一个clone方法，clone方法的功能就是拷贝父本的所有属性。主要包括两个过程： （1）分配一块新的内存空间给新的对象。 （2）拷贝父本对象的所有属性。\n2.2 浅拷贝与深拷贝\n浅拷贝只拷贝引用类型对象的指针（指向），而不拷贝引用类型对象指向的值；深拷贝则同时拷贝引用类型对象及其指向的值。 引用类型：对象本身可以修改，Python 中的引用类型有列表（List）、字典（Dictionary）、类对象。Python在赋值的时候默认是浅拷贝，\n二、设计思想 三、类图 Clone是克隆模式的基类，SubClassA和SubClassB是具体的实现类。 Python中由于有copy模块的支持，因此克隆模式实现起来非常简单，只有两个方法：深拷贝克隆deepClone和浅拷贝克隆clone，大部分情况下会用深拷贝的方式。\n四、代码框架 1 2 3 4 5 6 7 8 9 10 11 12 from copy import copy, deepcopy class Clone: \u0026#34;\u0026#34;\u0026#34;克隆的基类\u0026#34;\u0026#34;\u0026#34; def clone(self): \u0026#34;\u0026#34;\u0026#34;浅拷贝的方式克隆对象\u0026#34;\u0026#34;\u0026#34; return copy(self) def deepClone(self): \u0026#34;\u0026#34;\u0026#34;深拷贝的方式克隆对象\u0026#34;\u0026#34;\u0026#34; return deepcopy(self) 五、模型说明 1.设计要点 克隆模式也叫原型模式，应用场景非常广泛。在Java中与基类Object融为一体，可以随手就拿来用，只要implements Cloneabble接口就默认拥有了克隆的功能。而在Python中，克隆模式成为了语言本身的一部分，因为Python中对象的赋值就是一个浅拷贝的过程。 在设计克隆模式时，唯一需要注意的是：区分浅拷贝与深拷贝，除非一些特殊情况（如需求本身就要求两个对象一起改变），尽量使用深拷贝的方式。 2.克隆模式的优缺点 优点： （1）克隆模式通过内存拷贝的方式进行复制，比new的方式创建对象性能更好。 （2）通过深拷贝的方式，可以方便地创建一个具有相同属性和行为的另一个对象，特别是对于复杂对象，方便性尤为突出。 缺点： 通过克隆的方式创建对象，不会执行类的初始化函数（init）。这不一定是缺点，但大家使用的时候需要注意这一点。\n六、应用说明 （1）如果创建新对象（如复杂对象）成本较高，我们可以利用已有的对象进行复制来获得。 （2）类的初始化需要消耗非常多的资源时，如需要消耗很多的数据、硬件等资源。 （3）可配合备忘录模式做一些备份的工作。\n七、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 #!/usr/bin/python # Version 1.0 #======================================================================================================================= # from copy import copy, deepcopy # # class Person: # \u0026#34;\u0026#34;\u0026#34;人\u0026#34;\u0026#34;\u0026#34; # # def __init__(self, name, age): # self.__name = name # self.__age = age # # def showMyself(self): # print(\u0026#34;我是\u0026#34; + self.__name + \u0026#34;,年龄\u0026#34; + str(self.__age) + \u0026#34;.\u0026#34;) # # def coding(self): # print(\u0026#34;我是码农，我用程序改变世界，Coding...\u0026#34;) # # def reading(self): # print(\u0026#34;阅读使我快乐！知识使我成长！如饥似渴地阅读是生活的一部分...\u0026#34;) # # def fallInLove(self): # print(\u0026#34;春风吹，月亮明，花前月下好相约...\u0026#34;) # # def clone(self): # return copy(self) # 浅拷贝与深拷贝 #======================================================================================================================= from copy import copy, deepcopy class PetStore: \u0026#34;\u0026#34;\u0026#34;宠物店\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.__name = name self.__petList = [] def setName(self, name): self.__name = name def showMyself(self): print(\u0026#34;%s 宠物店有以下宠物：\u0026#34; % self.__name) for pet in self.__petList: print(pet + \u0026#34;\\t\u0026#34;, end=\u0026#34;\u0026#34;) print() def addPet(self, pet): self.__petList.append(pet) # Version 2.0 #======================================================================================================================= # 代码框架 #============================== from copy import copy, deepcopy class Clone: \u0026#34;\u0026#34;\u0026#34;克隆的基类\u0026#34;\u0026#34;\u0026#34; def clone(self): \u0026#34;\u0026#34;\u0026#34;浅拷贝的方式克隆对象\u0026#34;\u0026#34;\u0026#34; return copy(self) def deepClone(self): \u0026#34;\u0026#34;\u0026#34;深拷贝的方式克隆对象\u0026#34;\u0026#34;\u0026#34; return deepcopy(self) # 基于框架的实现 #============================== class Person(Clone): \u0026#34;\u0026#34;\u0026#34;人\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age): self.__name = name self.__age = age def showMyself(self): print(\u0026#34;我是\u0026#34; + self.__name + \u0026#34;,年龄\u0026#34; + str(self.__age) + \u0026#34;.\u0026#34;) def coding(self): print(\u0026#34;我是码农，我用程序改变世界，Coding...\u0026#34;) def reading(self): print(\u0026#34;阅读使我快乐！知识使我成长！如饥似渴地阅读是生活的一部分...\u0026#34;) def fallInLove(self): print(\u0026#34;春风吹，月亮明，花前月下好相约...\u0026#34;) # 实战应用 # ======================================================================================================================= class AppConfig(Clone): \u0026#34;\u0026#34;\u0026#34;应用程序功能配置\u0026#34;\u0026#34;\u0026#34; def __init__(self, configName): self.__configName = configName self.parseFromFile(\u0026#34;./config/default.xml\u0026#34;) def parseFromFile(self, filePath): \u0026#34;\u0026#34;\u0026#34; 从配置文件中解析配置项 真实项目中通过会将配置保存到配置文件中，保证下次开启时依然能够生效； 这里为简单起见，不从文件中读取，以初始化的方式来模拟。 \u0026#34;\u0026#34;\u0026#34; self.__fontType = \u0026#34;宋体\u0026#34; self.__fontSize = 14 self.__language = \u0026#34;中文\u0026#34; self.__logPath = \u0026#34;./logs/appException.log\u0026#34; def saveToFile(self, filePath): \u0026#34;\u0026#34;\u0026#34; 将配置保存到配置文件中 这里为简单起见，不再实现 \u0026#34;\u0026#34;\u0026#34; pass def copyConfig(self, configName): \u0026#34;\u0026#34;\u0026#34;创建一个配置的副本\u0026#34;\u0026#34;\u0026#34; config = self.deepClone() config.__configName = configName return config def showInfo(self): print(\u0026#34;%s 的配置信息如下：\u0026#34; % self.__configName) print(\u0026#34;字体：\u0026#34;, self.__fontType) print(\u0026#34;字号：\u0026#34;, self.__fontSize) print(\u0026#34;语言：\u0026#34;, self.__language) print(\u0026#34;异常文件的路径：\u0026#34;, self.__logPath) def setFontType(self, fontType): self.__fontType = fontType def setFontSize(self, fontSize): self.__fontSize = fontSize def setLanguage(self, language): self.__language = language def setLogPath(self, logPath): self.__logPath = logPath # Test #======================================================================================================================= def testClone(): tony = Person(\u0026#34;Tony\u0026#34;, 27) tony.showMyself() tony.coding() tony1 = tony.clone() tony1.showMyself() tony1.reading() tony2 = tony.clone() tony2.showMyself() tony2.fallInLove() def testPetStore(): petter = PetStore(\u0026#34;Petter\u0026#34;) petter.addPet(\u0026#34;小狗Coco\u0026#34;) print(\u0026#34;父本petter：\u0026#34;, end=\u0026#34;\u0026#34;) petter.showMyself() print() petter1 = deepcopy(petter) petter1.addPet(\u0026#34;小猫Amy\u0026#34;) print(\u0026#34;副本petter1：\u0026#34;, end=\u0026#34;\u0026#34;) petter1.showMyself() print(\u0026#34;父本petter：\u0026#34;, end=\u0026#34;\u0026#34;) petter.showMyself() print() petter2 = copy(petter) petter2.addPet(\u0026#34;小兔Ricky\u0026#34;) print(\u0026#34;副本petter2：\u0026#34;, end=\u0026#34;\u0026#34;) petter2.showMyself() print(\u0026#34;父本petter：\u0026#34;, end=\u0026#34;\u0026#34;) petter.showMyself() def testList(): list = [1, 2, 3]; list1 = list; print(\u0026#34;id(list):\u0026#34;, id(list)) print(\u0026#34;id(list1):\u0026#34;, id(list1)) print(\u0026#34;修改之前：\u0026#34;) print(\u0026#34;list:\u0026#34;, list) print(\u0026#34;list1:\u0026#34;, list1) list1.append(4); print(\u0026#34;修改之后：\u0026#34;) print(\u0026#34;list:\u0026#34;, list) print(\u0026#34;list1:\u0026#34;, list1) # petter = PetStore(\u0026#34;Petter\u0026#34;) # petter.addPet(\u0026#34;小狗Coco\u0026#34;) # print(\u0026#34;父本tony：\u0026#34;, end=\u0026#34;\u0026#34;) # petter.showMyself() # # petter1 = petter # petter1.addPet(\u0026#34;小猫Amy\u0026#34;) # print(\u0026#34;副本tony1：\u0026#34;, end=\u0026#34;\u0026#34;) # petter1.showMyself() # print(\u0026#34;父本tony：\u0026#34;, end=\u0026#34;\u0026#34;) # petter.showMyself() def testAppConfig(): defaultConfig = AppConfig(\u0026#34;default\u0026#34;) defaultConfig.showInfo() print() newConfig = defaultConfig.copyConfig(\u0026#34;tonyConfig\u0026#34;) newConfig.setFontType(\u0026#34;雅黑\u0026#34;) newConfig.setFontSize(18) newConfig.setLanguage(\u0026#34;English\u0026#34;) newConfig.showInfo() # testClone() # testPetStore() # testList() testAppConfig() ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/4.3%E5%85%8B%E9%9A%86%E6%A8%A1%E5%BC%8F/","title":"4.3克隆模式"},{"content":"一、概念 Attach additional responsibilities to an object dynamically.Decorators provide a flexible alternative to subclassing for extending functionality. 动态地给一个对象增加一些额外的职责，就拓展对象功能来说，装饰模式比生成子类的方式更为灵活。\n二、设计思想 动态地给一个类增加额外的功能，而不改动原有的代码，就可用装饰模式来进行拓展。\n三、类图 图4-3中的Component是一个抽象类，代表具有某种功能（function）的组件，ComponentImplA和ComponentImplB分别是其具体的实现子类。Decorator是Component的装饰器，里面有一个Component的对象decorated，这就是被装饰的对象，装饰器可为被装饰对象添加额外的功能或行为（addBehavior）。DecoratorImplA和DecoratorImplB分别是两个具体的装饰器（实现子类）。 这样一种模式很好地将装饰器与被装饰的对象进行了解耦。\n四、模型说明 1.装饰模式的优缺点 优点： （1）使用装饰模式来实现扩展比使用继承更加灵活，它可以在不创造更多子类的情况下，将对象的功能加以扩展。 （2）可以动态地给一个对象附加更多的功能。 （3）可以用不同的装饰器进行多重装饰，装饰的顺序不同，可能产生不同的效果。 （4）装饰类和被装饰类可以独立发展，不会相互耦合；装饰模式相当于继承的一个替代模式。 缺点： 与继承相比，用装饰的方式拓展功能容易出错，排错也更困难。对于多次装饰的对象，调试寻找错误时可能需要逐级排查，较为烦琐。 3.Python装饰器与装饰模式的区别与联系 在“4.3.2 Python中的装饰器”一节中讲了Python中装饰器的原理和用法，它与我们在这一章讲的装饰模式的设计模式有什么区别呢？二者的区别如表4-1所示。 表4-1 Python装饰器与装饰模式的区别 二者的联系是，设计的思想相似，即要达到的目标是相似的：更好的拓展性，以及在不需要做太多代码变动的前提下，增加额外的功能。\n五、应用说明 （1）有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长时。 （2）需要动态地增加或撤销功能时。 （3）不能采用生成子类的方法进行扩充时，类的定义不能用于生成子类（如Java中的final类）。 装饰模式的应用场景非常广泛。如在实际项目开发中经常看到的过滤器，便可用装饰模式的方式实现。如果你是Java程序员，那么你对I/O中的FilterInputStream和FilterOutputStream一定不陌生，它的实现其实就是一个装饰模式。FilterInputStream（FilterOutputStream）就是一个装饰器，而InputStream（OutputStream）就是被装饰的对象。我们看一下创建对象的过程： ￼ 这个写法与上面Demo中的decorateTeacher=GlassesDecorator（WhiteShirtDecorator（LeatherShoesDecorator（Teacher（\u0026ldquo;wells\u0026rdquo;,\u0026ldquo;教授\u0026rdquo;））））是不是很相似？它们都是用一个对象套一个对象的方式进行创建的。\n六、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 # Version 1.0 #======================================================================================================================= from abc import ABCMeta, abstractmethod # 引入ABCMeta和abstractmethod来定义抽象类和抽象方法 class Person(metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;人\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self._name = name @abstractmethod def wear(self): print(\u0026#34;着装：\u0026#34;) class Engineer(Person): \u0026#34;\u0026#34;\u0026#34;工程师\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, skill): super().__init__(name) self.__skill = skill def getSkill(self): return self.__skill def wear(self): print(\u0026#34;我是 \u0026#34; + self.getSkill() + \u0026#34;工程师 \u0026#34; + self._name, end=\u0026#34;， \u0026#34;) super().wear() class Teacher(Person): \u0026#34;教师\u0026#34; def __init__(self, name, title): super().__init__(name) self.__title = title def getTitle(self): return self.__title def wear(self): print(\u0026#34;我是 \u0026#34; + self._name + self.getTitle(), end=\u0026#34;， \u0026#34;) super().wear() class ClothingDecorator(Person): \u0026#34;\u0026#34;\u0026#34;服装装饰器的基类\u0026#34;\u0026#34;\u0026#34; def __init__(self, person): self._decorated = person def wear(self): self._decorated.wear() self.decorate() @abstractmethod def decorate(self): pass class CasualPantDecorator(ClothingDecorator): \u0026#34;\u0026#34;\u0026#34;休闲裤装饰器\u0026#34;\u0026#34;\u0026#34; def __init__(self, person): super().__init__(person) def decorate(self): print(\u0026#34;一条卡其色休闲裤\u0026#34;) class BeltDecorator(ClothingDecorator): \u0026#34;\u0026#34;\u0026#34;腰带装饰器\u0026#34;\u0026#34;\u0026#34; def __init__(self, person): super().__init__(person) def decorate(self): print(\u0026#34;一条银色针扣头的黑色腰带\u0026#34;) class LeatherShoesDecorator(ClothingDecorator): \u0026#34;\u0026#34;\u0026#34;皮鞋装饰器\u0026#34;\u0026#34;\u0026#34; def __init__(self, person): super().__init__(person) def decorate(self): print(\u0026#34;一双深色休闲皮鞋\u0026#34;) class KnittedSweaterDecorator(ClothingDecorator): \u0026#34;\u0026#34;\u0026#34;针织毛衣装饰器\u0026#34;\u0026#34;\u0026#34; def __init__(self, person): super().__init__(person) def decorate(self): print(\u0026#34;一件紫红色针织毛衣\u0026#34;) class WhiteShirtDecorator(ClothingDecorator): \u0026#34;\u0026#34;\u0026#34;白色衬衫装饰器\u0026#34;\u0026#34;\u0026#34; def __init__(self, person): super().__init__(person) def decorate(self): print(\u0026#34;一件白色衬衫\u0026#34;) class GlassesDecorator(ClothingDecorator): \u0026#34;\u0026#34;\u0026#34;眼镜装饰器\u0026#34;\u0026#34;\u0026#34; def __init__(self, person): super().__init__(person) def decorate(self): print(\u0026#34;一副方形黑框眼镜\u0026#34;) # Test #======================================================================================================================= def testDecorator(): tony = Engineer(\u0026#34;Tony\u0026#34;, \u0026#34;客户端\u0026#34;) pant = CasualPantDecorator(tony) belt = BeltDecorator(pant) shoes = LeatherShoesDecorator(belt) shirt = WhiteShirtDecorator(shoes) sweater = KnittedSweaterDecorator(shirt) glasses = GlassesDecorator(sweater) glasses.wear() print() decorateTeacher = GlassesDecorator(WhiteShirtDecorator(LeatherShoesDecorator(Teacher(\u0026#34;wells\u0026#34;, \u0026#34;教授\u0026#34;)))) decorateTeacher.wear() def testDecorator2(): tony = Engineer(\u0026#34;Tony\u0026#34;, \u0026#34;客户端\u0026#34;) sweater = KnittedSweaterDecorator(tony) shirt = WhiteShirtDecorator(sweater) glasses = GlassesDecorator(shirt) glasses.wear() # testDecorator() # testDecorator2() ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/5.1%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","title":"5.1装饰模式"},{"content":"一、概念 二、设计思想 三、类图 四、代码框架 五、模型说明 六、应用说明 七、代码示例 ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/5.2%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"5.2代理模式"},{"content":"","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/%E4%B8%89%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"三、行为型模式"},{"content":" 结构型模式（Structural Pattern）关注如何将现有类或对象组织在一起形成更加强大的结构。不同的结构型模式从不同的角度来组合类或对象，在尽可能满足各种面向对象设计原则的同时，为类或对象的组合提供一系列巧妙的解决方案。 本部分将逐一介绍GoF设计模式中的7种结构型模式，其名称、定义、学习难度和使用频率如下表所示。\n模式名称 定义 学习难度 使用频率 适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口,使接口不兼容的那些类可以一起工作 ★★☆☆☆ ★★★★☆ 组合模式(Composite Pattern) 组合多个对象形成树形结构以表示具有“整体一部分”关系的层次结构 ★★★☆☆ ★★★★☆ 桥接模式\n(Bridge Pattern) 将抽象部分与其实现部分分离,使它们都可以独立地变化 ★★★☆☆ ★★★☆☆ 装饰模式(Decorator Pattern) 动态地给一个对象增加一些额外的职责 ★★★☆☆ ★★★☆☆ 外观模式(Facade Pattern) 外部与一个子系统的通信通过一个统一的外观对象进行,为子系统中的一组接口提供一个一致的入口 ★☆☆☆☆ ★★★★★ 享元模式(Flyweight Pattern) 运用共享技术有效地支持大量细粒度对象的复用 ★★★★☆ ★☆☆☆☆ 代理模式(Proxy Pattern) 给某一个对象提供一个代理,并由代理对象控制对原对象的引用 ★★★☆☆ ★★★★☆ ","date":"2020-09-09T00:00:00Z","permalink":"http://localhost:1313/p/%E4%BA%94%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"五、结构型模式"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-%E8%AF%AD%E6%B3%95/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:1313/p/markdown-%E8%AF%AD%E6%B3%95/","title":"Markdown 语法"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"},{"content":"[toc]\n一、概念 二、设计思想 三、类图 四、代码框架 五、模型说明 六、应用说明 七、代码示例 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""}]